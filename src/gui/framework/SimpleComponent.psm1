#Add types for WPF
Add-Type -AssemblyName PresentationFramework
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")

#sequence id for components over the lifetime of the application.
$_ComponentIdSeq = 0; 

#Constructor for creating a simple component,
#whether or not the component is a top-level component or a child component.
Function New-SimpleComponent([ScriptBlock] $ComponentDefScript, $Props) {
    _Log "New-SimpleComponent: ComponentDefScript: $($ComponentDefScript)"
    _Log "New-SimpleComponent: Props: $($Props | out-string)"
    $ComponentId = $script:_ComponentIdSeq++
    $NewComponent = New-Module -AsCustomObject -ArgumentList @($ComponentId, $ComponentDefScript, $Props) -ScriptBlock $_SimpleComponentDef

    _Log "Defining component $($NewComponent)"
    $NewComponent._DefineComponent()

    _Log "New-SimpleComponent: Return"
    return $NewComponent
}

$_SimpleComponentDef = {
    param($_ComponentId, [ScriptBlock] $_ComponentDefScript, $Props)

    $Children = @{};        #map of DIRECT child WPF components, eg MyButton1 => [WPF object]
                            #This map will NOT contain grandchild WPF components.
                            #This map will only be populated after _RealizeWpf has been called.
    $_Children = @{};       #map of child component objects, eg _SomeComponent123 => [SimpleComponent object]
                            #this will only be populated after _RealizeXaml has been called.
    [xml] $_Xaml = $null;   #the actual xaml used for this component
    [ScriptBlock] $_XamlScript = $null;   #the script to be executed to obtain the pre-realized xaml
    [ScriptBlock] $_InitScript = $null;   #the actual init script to call to initialize the component
    [String] $_XamlPlaceholder = "<_SimpleComponent_$($_ComponentId)/>";    #the xaml placeholder for this component, eg "<_SomeComponent123 />"
                                                                            #this will be autogenerated.
    $Wpf = $null;           #the WPF component that this component represents.
                            #This will only be populated after the component _RealizeWpf has been called.

    #Add a component to the children of this component.
    #The child component object will contain its definition script.
    function _AddComponentAsChild($Component) {
        _Log "_AddComponentAsChild: Component: $($Component)"
        $_Children[$Component.$_XamlPlaceholder] = $Component
    }

    #Convenience method to create a component object and 
    #add it as a child to this component object.
    function AddChild([ScriptBlock] $_ComponentDefScript, $_Props) {
        _Log "AddChild: _ComponentDefScript: $($_ComponentDefScript)"
        _Log "AddChild: _Props: $($_Props | out-string)"
        $ChildComponent = New-SimpleComponent $_ComponentDefScript $_Props
        _AddComponentAsChild $ChildComponent
    }

    #Run the definition script.
    #The result of this will be that the Xaml script and the Init script 
    #will have opportunity to be defined by the custom component.
    function _DefineComponent() {
        try {
            _Log "_DefineComponent: $($this)"
            &$this._ComponentDefScript $this
            _Log "_DefineComponent: $($this) Complete"
        } catch {
            $msg = "_DefineComponent: Error: $($_ | out-string)"
            _Log $msg
            throw $msg
        }
    }

    #Realize the xaml in this component by resolving the placeholders 
    #for each of this component's child components.
    #The result will be that this component and each of its children
    #will have valid xaml and no remaining placeholders.
    function _RealizeXaml() {
        _Log "_DefineComponent: $($this)"

        if (-not($this._XamlScript)) {
            $msg = "_RealizeXaml: Error. No xaml provided. Must provide a XAML script."
            _Log $msg
            throw $msg
        }

        $this._Xaml = &$this._XamlScript $this
        _Log "_DefineComponent: $($this) Complete"
    }

    #Realize the WPF component by loading the XAML as WPF object.
    #The result of this is that this component's WPF variable will contain the WPF object created.
    #This action will also create all of the "child" WPF components.
    #This method will then inspect all the WPF elements by their IDs to 
    #fill in the child component's WPF variable as well as the
    #child component's children map.
    function _RealizeWpf() {
        try {
            _Log "_RealizeWpf: $($this)"
            $WpfComponent = [Windows.Markup.XamlReader]::Load((New-Object System.Xml.XmlNodeReader $this._Xaml))
            $this.Wpf = $WpfComponent
            _Log "_RealizeWpf: $($this) Complete"
        } catch {
            _throw "_RealizeWpf: Error: $($_ | out-string)"
        }
    }

    #Initialize this component by calling its init script
    #and then calling each child's init script (if not $null).
    #The result will be that this component and each of its children
    #will have had their init scripts called.
    #This means that the WPF objects are fully initialized,
    #ready to be displayed.
    function _Init() {

    }

    #Assign the script that will be called to generate xaml.
    function Xaml([ScriptBlock] $XamlScript) {
        try {
            $this._XamlScript = $XamlScript
        } catch {
            _Throw "Xaml: Error: $($_ | out-string)"
        }
    }

    #Assign the script that will be called to initialize the wpf objects.
    function Init([ScriptBlock] $InitScript) {
        try {
            $this._InitScript = $InitScript
        } catch {
            _Throw "Init: Error: $($_ | out-string)"
        }
    }

    #String representation of this component.
    function ToString() {
        return "Framework.SimpleComponent[$($this._XamlPlaceholder)]"
    }

    Export-ModuleMember -Function *
    Export-ModuleMember -Variable *
}

#Log the activities of this component.
#Only log when in debug mode, ie, when $env:DEBUG is not empty.
Function _Log($msg) {
    if ($env:DEBUG) {
        write-host $msg
        $msg >> stuff.txt
    }
}

Function _Throw($msg) {
    _Log $msg
    throw $msg
}